#include <cmath>

namespace {

template <class T>
bool IsZero(T value, T eps) {
  return (std::fabs(value) < eps);
}

} // namespace

/*
 *
 * Constructors
 *
*/

template <class T>
Matrix<T>::Matrix(const T& mat)
    : mat_(mat) {}

template <class T>
Matrix<T>::Matrix(size_t rows, size_t columns)
    : mat_(vector<vector<T>>(rows, vector<T>(columns))) {}

template <class T>
Matrix<T>::Matrix(size_t rows, size_t columns, T value)
    : mat_(vector<vector<T>>(rows, vector<T>(columns, value))) {}

/*
 *
 * Getters
 *
*/

template <class T>
size_t Matrix<T>::rows() const {
  return mat_.size();
}

template <class T>
size_t Matrix<T>::columns() const {
  return mat_.begin()->size();
}

template <class T>
const vector<vector<T>>& Matrix<T>::mat() const {
  return mat_;
}

/*
 *
 * Iterators
 *
*/

template <class T>
typename vector<vector<T>>::iterator Matrix<T>::begin() {
  return mat_.begin();
}

template <class T>
typename vector<vector<T>>::iterator Matrix<T>::end() {
  return mat_.end();
}

template <class T>
typename vector<vector<T>>::const_iterator Matrix<T>::begin() const {
  return mat_.begin();
}

template <class T>
typename vector<vector<T>>::const_iterator Matrix<T>::end() const {
  return mat_.end();
}

/*
 *
 * Operators
 *
*/

template <class T>
vector<T>& Matrix<T>::operator[] (size_t id) {
  return mat_[id];
}

template <class T>
const vector<T>& Matrix<T>::operator[] (size_t id) const {
  return mat_[id];
}

template <class T>
bool Matrix<T>::operator== (const Matrix<T>& rhs) const {
  if (this->rows() != rhs.rows() || this->columns() != rhs.columns())
    return false;
  for (size_t i = 0; i < this->rows(); ++i)
    if (mat_[i] != rhs[i])
      return false;
  return true;
}

template <class T>
bool Matrix<T>::operator!= (const Matrix<T>& rhs) const {
  return !(*this == rhs);
}

template <class T> template <class Y>
Matrix<T>& Matrix<T>::operator= (const Matrix<Y>& rhs) {
  // Resize and allocate all needed memory.
  mat_ = vector<vector<T>>(rhs.rows());
  size_t resize_to = rhs.columns();
  for (auto& row : mat_)
    row.reserve(resize_to);

  for (size_t i = 0; i < rhs.rows(); ++i)
    mat_[i] = vector<T>(rhs[i].begin(), rhs[i].end());

  return *this;
}

/*
 *
 * Others
 *
*/

// Compare different types.
// Compare with eps value for floating point matrices.
template <class T> template <class Y>
bool Matrix<T>::equal(const Matrix<Y>& mat_y, T eps) {
  if (this->rows() != mat_y.rows() || this->columns() != mat_y.columns())
    return false;
  if (eps <= 0.0) {
    for (size_t i = 0; i < mat_.size(); ++i)
      for (size_t j = 0; j < mat_.begin()->size(); ++j)
        if (mat_[i][j] != T(mat_y[i][j]))
          return false;
  } else {
    // Check if near equal.
    for (size_t i = 0; i < mat_.size(); ++i)
      for (size_t j = 0; j < mat_.begin()->size(); ++j)
        if (!IsZero(mat_[i][j] - T(mat_y[i][j]), eps))
          return false;
  }
  return true;
}
