#include <cmath>
namespace delgon {
namespace {

template <class T>
bool IsZero(T value, T eps) {
  return (std::fabs(value) < eps);
}

} // namespace

/*
 *
 * Constructors
 *
*/

template <class T>
delgon::Matrix<T>::Matrix(Matrix<T>&& matrix)
    : mat_(std::move(matrix.mat_)) {
}

template <class T>
Matrix<T>::Matrix(const Matrix<T>& matrix)
    : mat_(matrix.mat_) {
}

template <class T>
Matrix<T>::Matrix(size_t rows, size_t columns)
    : mat_(std::vector<std::vector<T>>(rows, std::vector<T>(columns))) {
}

template <class T>
Matrix<T>::Matrix(size_t rows, size_t columns, T value)
    : mat_(std::vector<std::vector<T>>(rows, std::vector<T>(columns, value))) {
}

template <class T> template <class Y>
Matrix<T>::Matrix(const Matrix<Y>& matrix) {
  mat_.resize(matrix.num_rows());

  for (size_t i = 0; i < matrix.num_rows(); ++i) {
    mat_[i] = std::vector<T>(matrix[i].begin(), matrix[i].end());
  }
}

/*
 *
 * Getters
 *
*/

template <class T>
size_t Matrix<T>::num_rows() const {
  return mat_.size();
}

template <class T>
size_t Matrix<T>::num_columns() const {
  return (mat_.size()) ? mat_.begin()->size()
                       : 0;
}

/*
 *
 * Iterators
 *
*/

template <class T>
typename std::vector<std::vector<T>>::iterator Matrix<T>::begin() {
  return mat_.begin();
}

template <class T>
typename std::vector<std::vector<T>>::iterator Matrix<T>::end() {
  return mat_.end();
}

template <class T>
typename std::vector<std::vector<T>>::const_iterator Matrix<T>::begin() const {
  return mat_.begin();
}

template <class T>
typename std::vector<std::vector<T>>::const_iterator Matrix<T>::end() const {
  return mat_.end();
}

/*
 *
 * Operators
 *
*/

template <class T>
std::vector<T>& Matrix<T>::operator[] (size_t id) {
  return mat_[id];
}

template <class T>
const std::vector<T>& Matrix<T>::operator[] (size_t id) const {
  return mat_[id];
}

template <class T>
bool Matrix<T>::operator== (const Matrix<T>& rhs) const {
  if (num_rows() != rhs.num_rows() || num_columns() != rhs.num_columns())
    return false;
  for (size_t i = 0; i < num_rows(); ++i) {
    if (mat_[i] != rhs[i])
      return false;
  }
  return true;
}

template <class T>
bool Matrix<T>::operator!= (const Matrix<T>& rhs) const {
  return !(*this == rhs);
}


template <class T>
Matrix<T>& Matrix<T>::operator= (const Matrix<T>& rhs) {
  mat_ = rhs.mat_;
  return *this;
}

template <class T>
Matrix<T>& Matrix<T>::operator= (Matrix<T>&& rhs) {
  mat_ = std::move(rhs.mat_);
  return *this;
}

/*
 *
 * Others
 *
*/

// Compare different types.
// Compare with eps value for floating point matrices.
template <class T> template <class Y>
bool Matrix<T>::equal(const Matrix<Y>& mat_y, T eps) {
  if (num_rows() != mat_y.num_rows() || num_columns() != mat_y.num_columns())
    return false;
  if (eps <= 0.0) {
    for (size_t i = 0; i < num_rows(); ++i) {
      for (size_t j = 0; j < num_columns(); ++j) {
        if (mat_[i][j] != T{mat_y[i][j]})
          return false;
      }
    }
  } else {
    // Check if near equal.
    for (size_t i = 0; i < num_rows(); ++i) {
      for (size_t j = 0; j < num_columns(); ++j) {
        if (!IsZero(mat_[i][j] - T(mat_y[i][j]), eps))
          return false;
      }
    }
  }
  return true;
}

} // namesapce delgon
