#include <cassert>
#include <cmath>

namespace delgon {
namespace {

template <class T>
bool IsZero(T value, T eps = 1e-12) {
  return (std::fabs(value) < eps);
}

} // namespace

/*
 *
 * Constructors
 *
*/

template <class T>
delgon::Matrix<T>::Matrix(Matrix<T>&& matrix)
    : mat_(std::move(matrix.mat_)) {
}

template <class T>
Matrix<T>::Matrix(const Matrix<T>& matrix)
    : mat_(matrix.mat_) {
}

template <class T>
Matrix<T>::Matrix(size_t rows, size_t columns)
    : mat_(std::vector<std::vector<T>>(rows, std::vector<T>(columns))) {
}

template <class T>
Matrix<T>::Matrix(size_t rows, size_t columns, T value)
    : mat_(std::vector<std::vector<T>>(rows, std::vector<T>(columns, value))) {
}

template <class T> template <class Y>
Matrix<T>::Matrix(const Matrix<Y>& matrix) {
  mat_.resize(matrix.num_rows());

  for (size_t i = 0; i < matrix.num_rows(); ++i) {
    mat_[i] = std::vector<T>(matrix[i].begin(), matrix[i].end());
  }
}

/*
 *
 * Getters
 *
*/

template <class T>
size_t Matrix<T>::num_rows() const {
  return mat_.size();
}

template <class T>
size_t Matrix<T>::num_columns() const {
  return (mat_.size()) ? mat_.begin()->size()
                       : 0;
}

/*
 *
 * Iterators
 *
*/

template <class T>
typename std::vector<std::vector<T>>::iterator Matrix<T>::begin() {
  return mat_.begin();
}

template <class T>
typename std::vector<std::vector<T>>::iterator Matrix<T>::end() {
  return mat_.end();
}

template <class T>
typename std::vector<std::vector<T>>::const_iterator Matrix<T>::begin() const {
  return mat_.begin();
}

template <class T>
typename std::vector<std::vector<T>>::const_iterator Matrix<T>::end() const {
  return mat_.end();
}

/*
 *
 * Operators
 *
*/

template <class T>
std::vector<T>& Matrix<T>::operator[] (size_t id) {
  return mat_[id];
}

template <class T>
const std::vector<T>& Matrix<T>::operator[] (size_t id) const {
  return mat_[id];
}

template <class T>
bool Matrix<T>::operator== (const Matrix<T>& rhs) const {
  if (num_rows() != rhs.num_rows() || num_columns() != rhs.num_columns())
    return false;
  for (size_t i = 0; i < num_rows(); ++i) {
    if (mat_[i] != rhs[i])
      return false;
  }
  return true;
}

template <class T>
bool Matrix<T>::operator!= (const Matrix<T>& rhs) const {
  return !(*this == rhs);
}


template <class T>
Matrix<T>& Matrix<T>::operator= (const Matrix<T>& rhs) {
  mat_ = rhs.mat_;
  return *this;
}

template <class T>
Matrix<T>& Matrix<T>::operator= (Matrix<T>&& rhs) {
  mat_ = std::move(rhs.mat_);
  return *this;
}

/*
 *
 * Basic Operations
 *
 *
*/

template <class T>
Matrix<T> Matrix<T>::operator+ (const Matrix<T>& rhs) const {
  // Check matrices are - MxN * MxN.
  assert(num_rows() == rhs.num_rows() ||
         num_columns() == rhs.num_columns());

  Matrix<T> added(num_rows(), num_columns());
  for (size_t i = 0; i < num_rows(); ++i) {
    for (size_t j = 0; j < num_columns(); ++j) {
      added[i][j] = mat_[i][j] + rhs[i][j];
    }
  }
  return added;
}

template <class T>
Matrix<T> Matrix<T>::operator* (const T& rhs) const {
  Matrix<T> multiplied(num_rows(), num_columns());
  for (size_t i = 0; i < num_rows(); ++i) {
    for (size_t j = 0; j < num_columns(); ++j) {
      multiplied[i][j] = mat_[i][j] * rhs;
    }
  }
  return multiplied;
}

template <class T>
Matrix<T> Matrix<T>::operator* (const Matrix<T>& rhs) const {
  // Check matrices are MxN * NxP
  assert(num_columns() == rhs.num_rows());

  Matrix<T> multiplied(num_rows(), rhs.num_columns(), T{0});
  for (size_t i = 0; i < num_rows(); ++i) {
    for (size_t j = 0; j < rhs.num_columns(); ++j) {
      for (size_t k = 0; k < num_columns(); ++k)
        multiplied[i][j] += mat_[i][k] * rhs[k][j];
    }
  }
  return multiplied;
}

template <class T>
Matrix<T> Matrix<T>::Transpose() const {
  Matrix<T> transposed(num_columns(), num_rows());
  for (size_t i = 0; i < num_rows(); ++i) {
    for (size_t j = 0; j < num_columns(); ++j) {
      transposed[j][i] = mat_[i][j];
    }
  }
  return transposed;
}

template <class T>
Matrix<T>& Matrix<T>::TransposeInplace () {
  mat_ = std::move(this->Transpose().mat_);
  return *this;
}

template <class T>
Matrix<T>& Matrix<T>::RowAdditionInplace(size_t add_to, size_t add_from) {
  // Check if rows are within range.
  assert(add_to < num_rows() &&
         add_from < num_rows());

  for (size_t i = 0; i < num_columns(); ++i)
    mat_[add_to][i] += mat_[add_from][i];

  return *this;
}

template <class T>
Matrix<T>& Matrix<T>::RowMultiplicationInplace(size_t row, const T& value) {
  // Check if row is within range and if value is != 0;
  assert(row < num_rows() &&
         !IsZero(value));

  for (size_t i = 0; i < num_columns(); ++i)
    mat_[row][i] *= value;

  return *this;
}

template <class T>
Matrix<T>& Matrix<T>::RowSwitchInplace(size_t row1, size_t row2) {
  // Check if rows are within range.
  assert(row1 < num_rows() &&
         row2 < num_rows());

  std::swap(mat_[row1], mat_[row2]);

  return *this;
}

template <class T>
Matrix<T> Matrix<T>::RowAddition(size_t add_to, size_t add_from) const {
  return Matrix<T>(*this).RowAdditionInplace(add_to, add_from);
}

template <class T>
Matrix<T> Matrix<T>::RowMultiplication(size_t row, const T& value) const {
  return Matrix<T>(*this).RowMultiplicationInplace(row, value);
}

template <class T>
Matrix<T> Matrix<T>::RowSwitch(size_t row1, size_t row2) const {
  return Matrix<T>(*this).RowSwitchInplace(row1, row2);
}

template <class T>
Matrix<T>& Matrix<T>::SubmatrixInplace(std::vector<size_t> rows,
                                       std::vector<size_t> columns) {
  // Erase rows.
  std::sort(rows.begin(), rows.end(), std::greater<T>());
  for (const auto& row : rows) {
    assert(row < num_rows());
    mat_.erase(mat_.begin() + row);
  }

  // Erase columns.
  std::sort(columns.begin(), columns.end(), std::greater<T>());
  // Iterate from behind to avoid num_columns() change in value.
  for (size_t i = num_rows(); i > 0; --i) {
    for (const auto& column : columns) {
      assert(column < num_columns());
      mat_[i - 1].erase(mat_[i - 1].begin() + column);
    }
  }
  return *this;
}

template <class T>
Matrix<T> Matrix<T>::Submatrix(const std::vector<size_t>& rows,
                               const std::vector<size_t>& columns) const {
  return Matrix<T>(*this).SubmatrixInplace(rows, columns);
}

/*
 *
 * Others
 *
*/

// Compare different types.
// Compare with eps value for floating point matrices.
template <class T> template <class Y>
bool Matrix<T>::equal(const Matrix<Y>& mat_y, T eps) {
  if (num_rows() != mat_y.num_rows() || num_columns() != mat_y.num_columns())
    return false;
  if (std::signbit(eps)) {
    for (size_t i = 0; i < num_rows(); ++i) {
      for (size_t j = 0; j < num_columns(); ++j) {
        if (mat_[i][j] != static_cast<T>(mat_y[i][j]))
          return false;
      }
    }
  } else {
    // Check if near equal.
    for (size_t i = 0; i < num_rows(); ++i) {
      for (size_t j = 0; j < num_columns(); ++j) {
        if (!IsZero(mat_[i][j] - static_cast<T>(mat_y[i][j]), eps))
          return false;
      }
    }
  }
  return true;
}

} // namesapce delgon
